using Autofac;
using System.Reflection;
using Vortex.Modules.Networking.Abstraction;

namespace Vortex.Modules.Networking;

public class PacketSerializer
{
    private IEnumerable<FullPacketMapping> _mappings = [];

    public PacketSerializer() => SetupFullMappings();

    private void SetupFullMappings()
    {
        var packets = new List<(Type PacketType, int PacketId)>();

        foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
        {
            foreach (var type in assembly.GetTypes())
            {
                if (IsAssignableToGenericType(type, typeof(IPacketHandler<>)))
                {
                    var packetTypes = type.GetInterfaces()
                        .Where(i => i.IsClosedTypeOf(typeof(IPacketHandler<>)))
                        .Select(i => i.GetGenericArguments()[0]);

                    foreach (var packetType in packetTypes)
                    {
                        var id = packetType.GetCustomAttribute<PacketAttribute>()?.PacketId;
                        if (id is null)
                            return;

                        packets.Add((packetType, id.Value));
                    }
                }
            }
        }

        var mappings = new List<FullPacketMapping>();

        foreach ((Type packetType, int packetId) in packets)
        {
            if (packetType.GetCustomAttributes<AutoSerializedPacketAttribute>(true).Any())
            {
                var serializationType = Type.GetType($"{packetType.Namespace}.{packetType.Name}Serializer, {packetType.Assembly.FullName}")
                    ?? throw new Exception("Could not find autogenerated serialization logic");

                mappings.Add(new FullPacketMapping(packetType, packetId, serializationType));
            }
            else
            {
                var customAttribute = packetType.GetCustomAttributes(true).FirstOrDefault(a => a.GetType().IsClosedTypeOf(typeof(CustomSerializedAttribute<,>)))
                    ?? throw new Exception("Packet definition is missing AutoParsed or CustomParsed attribute");

                mappings.Add(new FullPacketMapping(packetType, packetId, customAttribute.GetType().GetGenericArguments().Last()));
            }
        }

        _mappings = mappings;
    }

    public int? GetOpCode(Type packetType)
        => _mappings.FirstOrDefault(m => m.PacketType == packetType)?.PacketId;

    public object DeserializePacket(int packetId, MinecraftBinaryReader reader)
    {
        var mapping = _mappings.FirstOrDefault(m => m.PacketId == packetId)
            ?? throw new Exception("Could not find Serializer Mapping for Packet Type");

        var serializer = Activator.CreateInstance(mapping.SerializerType);
        var deserializeMethodInfo = typeof(IPacketSerializer<>).MakeGenericType(mapping.PacketType).GetMethod(nameof(IPacketSerializer<HandshakePacket>.DeserializePacket))!;

        var packet = deserializeMethodInfo.Invoke(serializer, [reader])!;
        return packet;
    }

    public byte[] SerializePacket(Type packetType, object packet)
    {
        var mapping = _mappings.FirstOrDefault(m => m.PacketType == packet.GetType())
            ?? throw new Exception("Could not find Serializer Mapping for Packet Type");

        var serializer = Activator.CreateInstance(mapping.SerializerType);
        var serializeMethodInfo = typeof(IPacketSerializer<>).MakeGenericType(packetType).GetMethod(nameof(IPacketSerializer<HandshakePacket>.DeserializePacket))!;

        using var stream = new MemoryStream();
        using var writer = new MinecraftBinaryWriter(stream);

        serializeMethodInfo.Invoke(serializer, [writer, packet]);

        return stream.ToArray();
    }

    public record FullPacketMapping(Type PacketType, int PacketId, Type SerializerType);

    private static bool IsAssignableToGenericType(Type givenType, Type genericType)
    {
        var interfaceTypes = givenType.GetInterfaces();

        foreach (var it in interfaceTypes)
        {
            if (it.IsGenericType && it.GetGenericTypeDefinition() == genericType)
                return true;
        }

        if (givenType.IsGenericType && givenType.GetGenericTypeDefinition() == genericType)
            return true;

        var baseType = givenType.BaseType;
        if (baseType == null) return false;

        return IsAssignableToGenericType(baseType, genericType);
    }
}